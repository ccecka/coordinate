#pragma once

#include <array>
#include <initializer_list>
#include <type_traits>

namespace std
{


template<bool Value1, bool... Values>
struct __all_of
  : std::integral_constant<bool, Value1 && __all_of<Values...>::value>
{};


template<bool Value1> struct __all_of<Value1>
  : std::integral_constant<bool, Value1>
{};


// XXX shorten to coord?
template<class ArithmeticType, size_t Rank>
class coordinate
{
  static_assert(std::is_arithmetic<ArithmeticType>::value, "ArithmeticType must be an arithmetic type.");

  public:
    using value_type                = ArithmeticType;
    using reference                 = value_type&;
    using const_reference           = const value_type&;
    using size_type                 = size_t;
    using pointer                   = value_type*;
    using const_pointer             = const value_type*;
    using iterator                  = pointer;
    using const_iterator            = const_pointer;
    static constexpr size_type rank = Rank;

    coordinate() = default;

    coordinate(const coordinate& other) = default;

    // copies from another coordinate
    template<class OtherArithmeticType>
    coordinate(const coordinate<OtherArithmeticType,Rank>& other,
               typename enable_if<
                 is_arithmetic<OtherArithmeticType>::value
               >::type* = 0)
    {
      for(size_type i = 0; i < size(); ++i)
      {
        operator[](i) = other[i];
      }
    }

    // fills the coordinate with a constant value
    template<class OtherArithmeticType>
    coordinate(OtherArithmeticType val,
               typename enable_if<
                 is_arithmetic<OtherArithmeticType>::value
               >::type* = 0)
    {
      for(size_type i = 0; i < size(); ++i)
      {
        operator[](i) = val;
      }
    }

    // XXX how to use enable_if here?
    template<class... OtherArithmeticType>
    //coordinate(OtherArithmeticType... args<
    //           typename enable_if<
    //             __all_of<
    //               is_arithmetic<OtherArithmeticType>::value...
    //             >::value
    //           >::type* = 0)
    coordinate(OtherArithmeticType... args)
      : storage_{static_cast<value_type>(args)...}
    {}

    constexpr size_type size() const
    {
      return rank;
    }

    pointer data()
    {
      return storage_.data();
    }

    const_pointer data() const
    {
      return storage_.data();
    }

    iterator begin()
    {
      return storage_.begin();
    }

    iterator end()
    {
      return storage_.end();
    }

    const_iterator begin() const
    {
      return storage_.begin();
    }

    const_iterator end() const
    {
      return storage_.end();
    }

    const_iterator cbegin() const
    {
      return storage_.cbegin();
    }

    const_iterator cend() const
    {
      return storage_.cend();
    }

    bool operator==(const coordinate& rhs) const
    {
      return storage_ == rhs.storage_;
    }

    bool operator!=(const coordinate& rhs) const
    {
      return !(*this == rhs);
    }

    reference operator[](size_type n)
    {
      return storage_[n];
    }

    const_reference operator[](size_type n) const
    {
      return storage_[n];
    }

    // multiply by scalar
    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate&
    >::type
      operator*=(OtherArithmeticType rhs)
    {
      for(size_type i = 0; i < rank; ++i)
      {
        operator[](i) *= rhs;
      }

      return *this;
    }

    // divide by scalar
    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate&
    >::type
      operator/=(OtherArithmeticType rhs)
    {
      for(size_type i = 0; i < rank; ++i)
      {
        operator[](i) /= rhs;
      }

      return *this;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate&
    >::type
      operator+=(const coordinate<OtherArithmeticType,Rank>& rhs)
    {
      for(size_type i = 0; i < rank; ++i)
      {
        operator[](i) += rhs[i];
      }

      return *this;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate<
        typename common_type<ArithmeticType,OtherArithmeticType>::type,
        Rank
      >
    >::type
      operator+(const coordinate<OtherArithmeticType,Rank>& rhs) const
    {
      using result_type = coordinate<typename common_type<ArithmeticType,OtherArithmeticType>::type, Rank>;

      return result_type{*this} += rhs;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate&
    >::type
      operator-=(const coordinate<OtherArithmeticType,Rank>& rhs)
    {
      for(size_type i = 0; i < rank; ++i)
      {
        operator[](i) -= rhs[i];
      }

      return *this;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate<
        typename common_type<ArithmeticType,OtherArithmeticType>::type,
        Rank
      >
    >::type
      operator-(const coordinate<OtherArithmeticType,Rank>& rhs) const
    {
      using result_type = coordinate<typename common_type<ArithmeticType,OtherArithmeticType>::type, Rank>;

      return result_type{*this} -= rhs;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate&
    >::type
      operator*=(const coordinate<OtherArithmeticType,Rank>& rhs)
    {
      for(size_type i = 0; i < rank; ++i)
      {
        operator[](i) *= rhs[i];
      }

      return *this;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate<
        typename common_type<ArithmeticType,OtherArithmeticType>::type,
        Rank
      >
    >::type
      operator*(const coordinate<OtherArithmeticType,Rank>& rhs) const
    {
      using result_type = coordinate<typename common_type<ArithmeticType,OtherArithmeticType>::type, Rank>;

      return result_type{*this} *= rhs;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate&
    >::type
      operator/=(const coordinate<OtherArithmeticType,Rank>& rhs)
    {
      for(size_type i = 0; i < rank; ++i)
      {
        operator[](i) /= rhs[i];
      }

      return *this;
    }

    template<class OtherArithmeticType>
    typename enable_if<
      is_arithmetic<OtherArithmeticType>::value,
      coordinate<
        typename common_type<ArithmeticType,OtherArithmeticType>::type,
        Rank
      >
    >::type
      operator/(const coordinate<OtherArithmeticType,Rank>& rhs) const
    {
      using result_type = coordinate<typename common_type<ArithmeticType,OtherArithmeticType>::type, Rank>;

      return result_type{*this} /= rhs;
    }

  private:
    std::array<ArithmeticType,Rank> storage_;
};


template<class ArithmeticType1, class ArithmeticType2, size_t Rank>
typename enable_if<
  is_arithmetic<ArithmeticType1>::value,
  coordinate<typename common_type<ArithmeticType1,ArithmeticType2>::type, Rank>
>::type
  operator*(ArithmeticType1 val, const coordinate<ArithmeticType2,Rank>& coord)
{
  return coordinate<ArithmeticType1,Rank>(val) * coord;
}


template<size_t I, class ArithmeticType, size_t Rank>
typename coordinate<ArithmeticType,Rank>::reference get(coordinate<ArithmeticType,Rank>& x)
{
  static_assert(I < Rank, "I must be less than Rank.");
  return x[I];
}


template<size_t I, class ArithmeticType, size_t Rank>
typename coordinate<ArithmeticType,Rank>::const_reference get(const coordinate<ArithmeticType,Rank>& x)
{
  static_assert(I < Rank, "I must be less than Rank.");
  return x[I];
}


template<size_t I, class Tuple>
struct tuple_element;


template<size_t I, class ArithmeticType, size_t Rank>
struct tuple_element<I,coordinate<ArithmeticType,Rank>>
{
  static_assert(I < Rank, "I must be less than Rank.");
  using type = ArithmeticType;
};


using int1  = coordinate<int,1>;
using int2  = coordinate<int,2>;
using int3  = coordinate<int,3>;
using int4  = coordinate<int,4>;
using int5  = coordinate<int,5>;
using int6  = coordinate<int,6>;
using int7  = coordinate<int,7>;
using int8  = coordinate<int,8>;
using int9  = coordinate<int,9>;
using int10 = coordinate<int,10>;


using size1  = coordinate<size_t,1>;
using size2  = coordinate<size_t,2>;
using size3  = coordinate<size_t,3>;
using size4  = coordinate<size_t,4>;
using size5  = coordinate<size_t,5>;
using size6  = coordinate<size_t,6>;
using size7  = coordinate<size_t,7>;
using size8  = coordinate<size_t,8>;
using size9  = coordinate<size_t,9>;
using size10 = coordinate<size_t,10>;


using float1  = coordinate<float,1>;
using float2  = coordinate<float,2>;
using float3  = coordinate<float,3>;
using float4  = coordinate<float,4>;
using float5  = coordinate<float,5>;
using float6  = coordinate<float,6>;
using float7  = coordinate<float,7>;
using float8  = coordinate<float,8>;
using float9  = coordinate<float,9>;
using float10 = coordinate<float,10>;


using double1  = coordinate<double,1>;
using double2  = coordinate<double,2>;
using double3  = coordinate<double,3>;
using double4  = coordinate<double,4>;
using double5  = coordinate<double,5>;
using double6  = coordinate<double,6>;
using double7  = coordinate<double,7>;
using double8  = coordinate<double,8>;
using double9  = coordinate<double,9>;
using double10 = coordinate<double,10>;


}

